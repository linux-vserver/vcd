\chapter{Introduction}
\label{ch:rpcref:intro}


\section{XML-RPC Signatures}

The XMLRPC signatures used in this part of the manual define a translation
between the XMLRPC value and C-friendly data types that represent the same
information. For example, it might say that a floating point number translates
to or from a C double value, or that an array of 4 integers translates to or
from 4 C int values.

A format string usually describes the type of one XMLRPC value. But some types
(array and structure) are compound types -- they are composed recursively of
other XMLRPC values. So a single format string might involve multiple XMLRPC
values.

But first, lets look at the simple (not compound) format types. These are easy.
The format string consists of one of the strings in the list below. The string
is called a format specifier, and in particular a simple format specifier.

The XMLRPC server uses only three native XMLRPC datatypes:

\begin{labeling}{00.00.0000}
\item [{\texttt{int}}] signed 32-bit integer (-2,147,483,648 to +2,147,483,647)
\item [{\texttt{bool}}] boolean value (true/false)
\item [{\texttt{string}}] character string of arbitrary length
\end{labeling}

Unfortunately the XMLRPC protocol does not define 64-bit integer values,
therefore the XMLRPC server uses the native string datatype and converts all
leading digit characters to 64-bit integer representation.

This chapter uses the following convention to denote these integer datatypes:

\begin{labeling}{00.00.0000}
\item [{\texttt{int32}}] signed 32-bit integer
	(-2,147,483,648 to +2,147,483,647)
\item [{\texttt{uint32}}] unsigned 32-bit integer
	(0 to +4,294,967,295)
\item [{\texttt{int64}}] signed 64-bit integer
	(-9,223,372,036,854,775,808 to +9,223,372,036,854,775,807)
\item [{\texttt{uint64}}] unsigned 64-bit integer
	(0 to +18,446,744,073,709,551,615)
\end{labeling}

The simple datatypes mentioned above are not sufficent to represent data in an
efficient way. Therefore compound datatypes are defined in XMLRPC. There are two
compound datatypes: array and struct.  The signature denotes arrays using
normal braces, structs use curly braces.

\begin{labeling}{00.00.0000}
\item [{\texttt{array}}] An array holds a series of data elements. Individual
	elements are accessed by their position array in the array.
\item [{\texttt{struct}}] A structure is a collection of simple datatypes under
	a single compund. This collection can be of different types, and each has
	a name which is used to select it from the structure. A structure is a
	convenient way of grouping several pieces of related information together.
\end{labeling}

Here are some examples of XMLRPC signatures:

\begin{itemize}
\item A single \texttt{string} datatype named \emph{path}:\\
	\texttt{string path}
\item An \texttt{array} of three int datatypes:\\
	\texttt{(int, int, int)}
\item An \texttt{array} with one \texttt{bool}, one \texttt{string} and one
	\texttt{int} datatype:\\
	\texttt{(bool, string, int)}
\item A \texttt{struct} with one \texttt{string} and one \texttt{int}
	datatype:\\
	\texttt{\{string name, int id\}}
\end{itemize}

Please note that the next chapters use the following convention to declare
methods and their parameters, although they do not involve arrays.

\begin{quote}
\texttt{vx.create(string name, string template, int rebuild)}
\end{quote}

Instead this convention matches the function declaration in the C language.
Translated to a XMLRPC signature format string the above would become a struct:

\begin{quote}
\texttt{\{string name, string template, int rebuild\}}
\end{quote}

Read on to the next section to learn how method requests are performed and how
this struct is placed in the request.


\section{Performing XML-RPC Requests}

An XMLRPC method call is an HTTP-POST request. The body of the request is in
XML. The specified method executes on the server and the value it returns is
also formatted in XML.

Here is an example of an XML-RPC request:

\begin{verbatim}
POST /RPC2 HTTP/1.0
User-Agent: VCC/1.0
Host: betty.userland.com
Content-Type: text/xml
Content-length: 181

<?xml version="1.0"?>
<methodCall>
<methodName>examples.getStateName</methodName>
<params>
<param>
<value><i4>41</i4></value>
</param>
</params>
</methodCall>
\end{verbatim}


\subsection{Header Requirements}

The following requirements must be met when sending requests to the XMLRPC
server:

\begin{itemize}
\item The \texttt{/RPC2} location handler to explicitly denote XMLRPC requests
\item A User-Agent and Host must be specified
\item The Content-Type is text/xml
\item The Content-Length must be specified and must be correct
\end{itemize}


\subsection{Payload Format}

The payload is in XML, a single \texttt{<methodCall>} structure.

The \texttt{<methodCall>} must contain a \texttt{<methodName>} sub-item, a
string, containing the name of the method to be called. The string may only
contain identifier characters, upper and lower-case A-Z, the numeric
characters, 0-9, underscore, dot, colon and slash.

If the procedure call has parameters, the <methodCall> must contain a <params>
sub-item. The <params> sub-item can contain any number of <param>s, each of
which has a <value>.


\subsubsection{Simple Datatypes}

The XMLRPC server only uses three native datatypes as mentioned above:

\begin{labeling}{00.00.0000}
\item [{\texttt{<int>}}] signed 32-bit integer
\item [{\texttt{<boolean>}}] 0 (false) or 1 (true)
\item [{\texttt{<string>}}] character string of arbitrary length
\end{labeling}

If no type is indicated, the type is string.


\subsubsection{Structures}

\subsubsection{Arrays}

\subsection{Method Initialization}

\subsection{Authentication and Access Restrictions}

\subsection{Response Format}



\section{Method Error Codes}
